<!--
 * @Date: 2022-10-30 18:57:19
 * @LastEditors: sunshaochen 805960031@qq.com
 * @LastEditTime: 2022-10-30 19:27:18
 * @FilePath: \ToFindWork\计算机基础-网络基础.md
-->
Q：OSI七层模型：
物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
扩展：
应用层：网络服务与最终用户的一个接口，常见的协议有：HTTP FTP SMTP SNMP DNS.
表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
会话层：建立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进行的会话.
传输层：定义传输数据的协议端口号，以及流控和差错校验,协议有TCP UDP.
网络层：进行逻辑地址寻址，实现不同网络之间的路径选择,协议有ICMP IGMP IP等.
数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。
物理层：建立、维护、断开物理连接。

Q：说一说三次挥手和4次握手

TCP作为一个传输层协议，是一个面向连接的字节流，为应用层提供端到端的传输服务
第一次握手是由客户端向服务器发送的SYN数据包。
第二次握手是服务器在接收到客户端的SYN数据包后发送给客户端的回应数据包。
第三次握手是客户端收到服务器的SYN数据包后，会发送一个数据包来应答

扩展：为什么需要三次握手而不是两次或者四次
两次握手出现的问题：

如果是两次握手的话，当服务器收到客户端发来的连接请求后，马上就要为客户端初始化内存，建立连接。 当出现以下异常情况的话，会造成资源浪费。

1、防止出现历史连接
TCP有超时重传机制，就是当一个数据报发送完之后，如果超过一段时间没有接收到对应的确认应答数据包，就会重新发送一次。

我们假设这样的情况，客户端第一次发送了一个SYN数据包1，seq为1，选择了一个耗费时间比较长的路由，导致过了超时时间还没有发送到服务器。这个时候客户端会重新发送一个SYN数据包2，seq为2,就是在SYN数据包2发送过程中，之前的SYN数据包1到达了服务器，这时服务器会发送一个SYN确认包3，对应的ack = 2。当客户端接收到SYN确认包3的时候，会比较ack和当前seq是否一样，这时客户端由于超时，已经发送了一个SYN数据包2，客户端中的seq已经增加到了3，不等于SYN确认包3中的ack 2，所以TCP会判定这是一个历史连接，就会发送一个RST标志位为1，seq = 2的数据包，RST的做法是将历史连接对应的节点从服务器中的半连接队列中移除。

如果是两次握手的话，对于失效连接是无法处理的，没有办法发送RST数据包了。

2、避免资源浪费
我们再假设这一种情况，也是数据包超时了，但是这时客户端没有重新发送，而是关闭了，当数据包传入到服务器的时候，服务器会为其创建连接，但是这时客户端已经关闭了。这就白白浪费了服务器的资源。

服务器中同一个端口的多个socket利用客户端IP和客户端端口号来唯一标识一个socket。

因为三次握手就可以满足建立连接的条件了，所以不需要四次握手了。


四次挥手：
第一次挥手由客户端发起断开请求，断开的是客户端向服务器写数据的方向连接，服务器还是能继续向客户端写入数据的。
第二次挥手是服务器接收到客户端的FIN数据包后，会返回确认应答包。
第三次挥手是服务器向客户端释放连接发送的FIN数据包。
第四次挥手是客户端向服务器发送的数据包。

扩展：为什么要四次挥手
TCP是一个全双工通信协议。客户端可以向服务器发送数据，服务器也能向客户端发送数据。
当客户端断开连接的时候，申请断开的是客户端向服务器发送数据的通道，当客户端向服务器发送数据的通道关闭之后，客户端还不能退出，因为客户端还可能有数据要收取。
这个时候服务器可能还有数据还未发送完给客户端。服务器向客户端发送数据的通道还不能关闭。等待服务器发送数据完毕之后，才会发送FIN数据包，并且要等待客户端的回应，因为FIN数据包可能会失效，所以客户端还需要再次向服务器发送ACK确认应答包。当服务器收到客户端的ACK时，才会真正关闭。
这就需要四次挥手。
